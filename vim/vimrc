set nocompatible              " be iMproved, required
filetype off                  " required

" Load vim-plug
if empty(glob("~/.vim/autoload/plug.vim"))
    execute '!curl -fLo ~/.vim/autoload/plug.vim https://raw.github.com/junegunn/vim-plug/master/plug.vim'
endif

" Specify a directory for plugins
" - For Neovim: ~/.local/share/nvim/plugged
" - Avoid using standard Vim directory names like 'plugin'
call plug#begin('~/.vim/plugged')

Plug 'rakr/vim-one'
Plug 'lukaszkorecki/CoffeeTags'
Plug 'scrooloose/nerdtree'
Plug 'scrooloose/syntastic'
Plug 'majutsushi/tagbar'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'kchmck/vim-coffee-script'
Plug 'digitaltoad/vim-jade'
Plug 'eparreno/vim-l9'
Plug 'elixir-lang/vim-elixir'
Plug 'fatih/vim-go'
Plug 'davidhalter/jedi-vim'
Plug 'tpope/vim-fugitive'
Plug 'leafgarland/typescript-vim'
Plug 'mileszs/ack.vim'
Plug 'mrtazz/simplenote.vim'
Plug 'Chiel92/vim-autoformat'
Plug 'janko-m/vim-test'
Plug 'flowtype/vim-flow'
if has('nvim')
  Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
  Plug 'wokalski/autocomplete-flow'
  " For func argument completion
  Plug 'Shougo/neosnippet'
  Plug 'Shougo/neosnippet-snippets'
else
  Plug 'Shougo/deoplete.nvim'
  Plug 'roxma/nvim-yarp'
  Plug 'roxma/vim-hug-neovim-rpc'
endif
let g:deoplete#enable_at_startup = 1
let g:neosnippet#enable_completed_snippet = 1
"
"
" All of your Plugins must be added before the following line
call plug#end()            " required

filetype plugin indent on    " required

syntax enable
filetype plugin indent on

" Theme
syntax on
" colorscheme solarized
" colorscheme desert
colorscheme one
set background=light

" Tabs as spaces
set smartindent
set tabstop=4
set shiftwidth=4
set expandtab

" Basic settings
set backspace=indent,eol,start
set number
set ruler
set showcmd
set incsearch
set hlsearch
set title

" Enable mouse
set mouse=a

" keep undo between sessions
set undofile
set undodir=/tmp/vimundo/

" Coffeescript
let coffee_indent_keep_current = 1
let coffee_linter = '/usr/local/bin/coffeelint'
let coffee_lint_options = '-f ~/coffeelint.json'

" Tagbar
nmap <c-a> :TagbarToggle<CR>
command Lint CoffeeLint | :botright cwindow

let g:tagbar_type_go = {
            \ 'ctagstype' : 'go',
            \ 'kinds'     : [
            \ 'p:package',
            \ 'i:imports:1',
            \ 'c:constants',
            \ 'v:variables',
            \ 't:types',
            \ 'n:interfaces',
            \ 'w:fields',
            \ 'e:embedded',
            \ 'm:methods',
            \ 'r:constructor',
            \ 'f:functions'
            \ ],
            \ 'sro' : '.',
            \ 'kind2scope' : {
            \ 't' : 'ctype',
            \ 'n' : 'ntype'
            \ },
            \ 'scope2kind' : {
            \ 'ctype' : 't',
            \ 'ntype' : 'n'
            \ },
            \ 'ctagsbin'  : 'gotags',
            \ 'ctagsargs' : '-sort -silent'
            \ }

" Auto open
autocmd vimenter * NERDTree
let g:NERDTreeWinSize = 40

" autocmd vimenter * TagbarToggle

" NerdTREE
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif
nmap <Leader>x :NERDTreeToggle<CR>
" " reveal the current file in NERDTree
map <Leader>f :NERDTreeFind<CR>
" let NERDTreeQuitOnOpen = 1
" let NERDTreeStatusLine = -1

" C++ header/source switch
nmap <F4> :e %:p:s,.hh$,.X123X,:s,.cc$,.hh,:s,.X123X$,.cc,<CR>

" OSX clipboard
if !has('nvim-0.1.5')        " True color in neovim wasn't added until 0.1.5
    set clipboard=unnamedplus,unnamed,autoselect
endif


" Macros for quoting/unquting words
" 'quote' a word
nnoremap qw :silent! normal mpea'<Esc>bi'<Esc>`pl
" double quote a word
nnoremap qd :silent! normal mpea"<Esc>bi"<Esc>`pl
" remove quotes from a word
nnoremap wq :silent! normal mpeld bhd `ph<CR>

" Auto remove trailing whitespaces on save
fun! <SID>StripTrailingWhitespaces()
    let l = line(".")
    let c = col(".")
    %s/\s\+$//e
    call cursor(l, c)
endfun

autocmd FileType c,cpp,java,php,ruby,python,js,coffee autocmd BufWritePre <buffer> :call <SID>StripTrailingWhitespaces()
au BufNewFile,BufRead *.es6 set filetype=javascript

" ======= blig/vim-airline settings =====
" let g:airline_theme='one'
" Always show the status bar
" set laststatus=2

" Show PASTE if in paste mode
" let g:airline_detect_paste=1

" Show airline for tabs too
" let g:airline#extensions#tabline#enabled = 1

" ----- scrooloose/syntastic settings -----
let g:syntastic_error_symbol = '✘'
let g:syntastic_warning_symbol = "▲"
let g:syntastic_javascript_checkers=['eslint']
let g:syntastic_python_checkers = ['pylint']
let g:syntastic_python_pylint_post_args = '--msg-template="{path}:{line}:{column}:{C}: [{symbol} {msg_id}] {msg}"'
let g:syntastic_swift_checkers = ['swiftpm', 'swiftlint']
augroup mySyntastic
    au!
    au FileType tex let b:syntastic_mode = "passive"
augroup END

" FuzzyFinder keybindings
function! OpenFile()
    if stridx(bufname("%"),"NERD_tree") >= 0
        :wincmd w
    endif
    :FufFile
endfunction
noremap <silent> <c-p> :call OpenFile()<CR>
function! OpenBuffer()
    if stridx(bufname("%"),"NERD_tree") >= 0
        :wincmd w
    endif
    :FufBuffer
endfunction
noremap <silent> <D-b> :call OpenBuffer()<CR>

" coffeescript textobjects indent stuff
" See http://andrewradev.com/2012/04/03/manipulating-coffeescript-with-vim-part-1-text-objects/
" for details on the implementation

onoremap ii :<c-u>call <SID>IndentTextObject()<cr>
onoremap аi :<c-u>call <SID>IndentTextObject()<cr>
xnoremap ii :<c-u>call <SID>IndentTextObject()<cr>
xnoremap ai :<c-u>call <SID>IndentTextObject()<cr>
function! s:IndentTextObject()
    let upper = s:UpperIndentLimit(line('.'))
    let lower = s:LowerIndentLimit(line('.'))
    call s:MarkVisual('V', upper, lower)
endfunction

onoremap if :<c-u>call <SID>FunctionTextObject('i')<cr>
onoremap af :<c-u>call <SID>FunctionTextObject('a')<cr>
xnoremap if :<c-u>call <SID>FunctionTextObject('i')<cr>
xnoremap af :<c-u>call <SID>FunctionTextObject('a')<cr>
function! s:FunctionTextObject(type)
    let function_start = search('\((.\{-})\)\=\s*[-=]>$', 'Wbc')
    if function_start <= 0
        return
    endif

    let body_start = function_start + 1
    if body_start > line('$') || indent(nextnonblank(body_start)) <= indent(function_start)
        if a:type == 'a'
            normal! vg_
        endif

        return
    endif

    let indent_limit = s:LowerIndentLimit(body_start)

    if a:type == 'i'
        let start = body_start
    else
        let start = function_start
    endif

    call s:MarkVisual('v', start, indent_limit)
endfunction

function! s:LowerIndentLimit(lineno)
    let base_indent  = indent(a:lineno)
    let current_line = a:lineno
    let next_line    = nextnonblank(current_line + 1)

    while current_line < line('$') && indent(next_line) >= base_indent
        let current_line = next_line
        let next_line    = nextnonblank(current_line + 1)
    endwhile

    return current_line
endfunction

function! s:UpperIndentLimit(lineno)
    let base_indent  = indent(a:lineno)
    let current_line = a:lineno
    let prev_line    = prevnonblank(current_line - 1)

    while current_line > 0 && indent(prev_line) >= base_indent
        let current_line = prev_line
        let prev_line    = prevnonblank(current_line - 1)
    endwhile

    return current_line
endfunction

function! s:MarkVisual(command, start_line, end_line)
    if a:start_line != line('.')
        exe a:start_line
    endif

    if a:end_line > a:start_line
        exe 'normal! '.a:command.(a:end_line - a:start_line).'jg_'
    else
        exe 'normal! '.a:command.'g_'
    endif
endfunction

" :shell
function! s:ExecuteInShell(command)
    let command = join(map(split(a:command), 'expand(v:val)'))
    let winnr = bufwinnr('^' . command . '$')
    silent! execute  winnr < 0 ? 'botright new ' . fnameescape(command) : winnr . 'wincmd w'
    setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile nowrap number
    echo 'Execute ' . command . '...'
    silent! execute 'silent %!'. command
    silent! execute 'resize ' . 10
    silent! execute '$'
    silent! redraw
    silent! execute 'au BufUnload <buffer> execute bufwinnr(' . bufnr('#') . ') . ''wincmd w'''
    silent! execute 'nnoremap <silent> <buffer> <LocalLeader>r :call <SID>ExecuteInShell(''' . command . ''')<CR>'
    echo 'Shell command ' . command . ' executed.'
endfunction
command! -complete=shellcmd -nargs=+ Shell call s:ExecuteInShell(<q-args>)

" auto run npm test
" autocmd BufWritePost *.coffee Shell npm test
au BufWrite *\.js :Autoformat
silent! so .vimlocal


" find in files
:set wildignore+=node_modules/**
noremap <F4> :Ack <cword><cr>

" vim-test
nmap <silent> <leader>t :TestNearest<CR>
nmap <silent> <leader>T :TestFile<CR>
nmap <silent> <leader>a :TestSuite<CR>
nmap <silent> <leader>l :TestLast<CR>
nmap <silent> <leader>g :TestVisit<CR>
let test#javascript#mocha#file_pattern = 'mocha'
let test#javascript#runner = 'jest'

" vim-flow
" "Use locally installed flow
let local_flow = finddir('node_modules', '.;') . '/.bin/flow'
if matchstr(local_flow, "^\/\\w") == ''
    let local_flow= getcwd() . "/" . local_flow
endif
if executable(local_flow)
  let g:flow#flowpath = local_flow
endif
let g:flow#autoclose = 1
let g:flow#errjmp = 1

filetype plugin on
set omnifunc=syntaxcomplete#Complete

" NeoVIM
if has('nvim-0.1.5')        " True color in neovim wasn't added until 0.1.5
    set termguicolors
endif
